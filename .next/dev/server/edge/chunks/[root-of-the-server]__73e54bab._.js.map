{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'crypto')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`crypto`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/auth.ts"],"sourcesContent":["// lib/auth.ts\nimport { PrismaClient } from \"@prisma/client\";\nimport { compare } from \"bcryptjs\";\nimport type { NextAuthOptions } from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  session: { strategy: \"jwt\" },\n  pages: { signIn: \"/login\" },\n  providers: [\n    Credentials({\n      name: \"Email & Password\",\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(creds) {\n        const email = creds?.email?.trim().toLowerCase();\n        const password = creds?.password ?? \"\";\n        if (!email || !password) return null;\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n          // ⚠️ schema에 맞춰 ‘password’ 컬럼을 선택\n          select: { id: true, email: true, name: true, role: true, password: true },\n        });\n        if (!user || !user.password) return null;\n\n        const ok = await compare(password, user.password);\n        if (!ok) return null;\n\n        // JWT에 씌워질 최소 정보 반환\n        return { id: user.id, email: user.email, name: user.name, role: user.role } as any;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = (user as any).id;\n        token.role = (user as any).role;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        (session.user as any).id = token.id as string;\n        (session.user as any).role = (token.role as any) ?? \"CLIENT\";\n      }\n      return session;\n    },\n  },\n};\n"],"names":[],"mappings":"AAAA,cAAc;;;;;AACd;AACA;AAEA;;;;AAEA,MAAM,SAAS,IAAI,qKAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,OAAO;QAAE,QAAQ;IAAS;IAC1B,WAAW;QACT,IAAA,2KAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,KAAK;gBACnB,MAAM,QAAQ,OAAO,OAAO,OAAO;gBACnC,MAAM,WAAW,OAAO,YAAY;gBACpC,IAAI,CAAC,SAAS,CAAC,UAAU,OAAO;gBAEhC,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;oBACf,kCAAkC;oBAClC,QAAQ;wBAAE,IAAI;wBAAM,OAAO;wBAAM,MAAM;wBAAM,MAAM;wBAAM,UAAU;oBAAK;gBAC1E;gBACA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE,OAAO;gBAEpC,MAAM,KAAK,MAAM,IAAA,oJAAO,EAAC,UAAU,KAAK,QAAQ;gBAChD,IAAI,CAAC,IAAI,OAAO;gBAEhB,oBAAoB;gBACpB,OAAO;oBAAE,IAAI,KAAK,EAAE;oBAAE,OAAO,KAAK,KAAK;oBAAE,MAAM,KAAK,IAAI;oBAAE,MAAM,KAAK,IAAI;gBAAC;YAC5E;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE;gBAC3B,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;YACjC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBACf,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;gBAClC,QAAQ,IAAI,CAAS,IAAI,GAAG,AAAC,MAAM,IAAI,IAAY;YACtD;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["// middleware.ts (프로젝트 루트)\n// Next 16 + next-auth v5 패턴\n\nimport { auth } from \"@/lib/auth\"; // 너의 auth 설정 위치\nimport type { Session } from \"next-auth\";\nimport type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\n// next-auth v5의 auth 콜백에 들어오는 req에 .auth가 붙어있다고 가정\ntype RequestWithAuth = NextRequest & { auth: Session | null };\n\nexport default auth((req: RequestWithAuth) => {\n  const { nextUrl } = req;\n\n  // 보호할 경로만 먼저 최소로 잡자 (필요시 확장)\n  const isProtected = nextUrl.pathname.startsWith(\"/admin\");\n\n  if (isProtected && !req.auth) {\n    // 로그인 안됐는데 보호 경로 접근 → 로그인으로\n    return NextResponse.redirect(new URL(\"/login\", nextUrl));\n  }\n\n  // 통과\n  return NextResponse.next();\n});\n\n// 어떤 경로에 미들웨어를 적용할지 명시\nexport const config = {\n  matcher: [\"/admin/:path*\"],\n};\n"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B,4BAA4B;;;;;;;AAE5B,2MAAmC,gBAAgB;AAGnD;AAAA;;;uCAKe,IAAA,2HAAI,EAAC,CAAC;IACnB,MAAM,EAAE,OAAO,EAAE,GAAG;IAEpB,6BAA6B;IAC7B,MAAM,cAAc,QAAQ,QAAQ,CAAC,UAAU,CAAC;IAEhD,IAAI,eAAe,CAAC,IAAI,IAAI,EAAE;QAC5B,4BAA4B;QAC5B,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU;IACjD;IAEA,KAAK;IACL,OAAO,gMAAY,CAAC,IAAI;AAC1B;AAGO,MAAM,SAAS;IACpB,SAAS;QAAC;KAAgB;AAC5B"}}]
}